<!DOCTYPE html>
<html>

<head>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
  </style>
</head>

<body>
  <script src='js/utils.js'></script>
  <script src='js/three.js'></script>
  <script src='js/GLTFLoader.js'></script>
  <script>

    // Scene

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 40, 70);
    camera.lookAt(0, 0, 0);

    // Renderer

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.color = new THREE.Color(0x808080);
    renderer.setClearColor(renderer.color);
    document.body.appendChild(renderer.domElement);

    // Lights

    const ambientLight = new THREE.AmbientLight(0xffffff);
    ambientLight.intensity = 0.25;
    scene.add(ambientLight);

    const frontLight = new THREE.DirectionalLight(0xffffff);
    frontLight.position.set(0, 1, 0.5);
    frontLight.intensity = 0.75;
    scene.add(frontLight);

    const backLight = new THREE.DirectionalLight(0xffffff);
    backLight.position.set(0, -1, 0);
    backLight.intensity = 0.75;
    scene.add(backLight);

    // 
    // Material
    // 

    const textureFiles = [
      'shared_diffuse_overlay',
      'shared_diffuse_none',
      'shared_bump_none',
      'shared_bump_buckram',
      'shared_bump_paper',
      'shared_foil_none',
      'POP_diffuse',
      'POP_bump',
      'GT_diffuse',
      'GT_bump',
      'GT_foil',
      'TDM_diffuse',
      'TDM_bump',
      'TDM_foil',
    ];

    const textures = textureFiles.reduce((textures, file) => {
      textures[file] = new THREE.TextureLoader().load(`v2-assets/${file}.jpg`);
      textures[file].name = file;
      textures[file].anisotropy = renderer.capabilities.getMaxAnisotropy();
      return textures;
    }, {});

    const vertexShader = `
      varying vec2 vUv;
      varying vec3 vViewPosition;
      varying vec3 vNormal;

      uniform float thickness;
      
      const float modelThickness = 1.3;

      void main() {
        vUv = vec2(uv.x, 1.0 - uv.y);

        // Normals

        vec3 objectNormal = vec3( normal );
        vec3 transformedNormal = normalMatrix * objectNormal;
        vNormal = normalize( transformedNormal );

        // Book thickness

        vec3 transformed = vec3( position );
        float thicknessDelta = (thickness - modelThickness);

        if (transformed.x > 1.0) transformed.x += thicknessDelta;
        else if (transformed.x < -1.0) transformed.x -= thicknessDelta;

        // Projection

        vec4 mvPosition = vec4( transformed, 1.0 );
        mvPosition = modelViewMatrix * mvPosition;

        gl_Position = projectionMatrix * mvPosition;

        vViewPosition = - mvPosition.xyz;
      }
    `;

    const fragmentShader = `
      #define PHONG

      varying vec2 vUv;

      uniform vec3 specular;
      uniform float shininess;

      uniform sampler2D diffuseMapBase;
      uniform sampler2D diffuseMapCustom;

      uniform sampler2D bumpMapBase;
      uniform sampler2D bumpMapCustom;
      uniform float bumpScaleBase;
      uniform float bumpScaleCustom;

      uniform sampler2D foilMap;
      uniform float foilDetail;
      uniform float foilOpacity;
      uniform float foilSpecular;
      const vec2 foilUvSize = vec2(0.14, -0.19);

      #include <common>
      #include <bsdfs>
      #include <lights_pars_begin>
      #include <lights_phong_pars_fragment>

      // 
      // Utils
      // 

      float blendOverlay(float base, float blend) {
        return base < 0.5 
          ? 2.0 * base * blend 
          : 1.0 - 2.0 * (1.0 - base) * (1.0 - blend);
      }

      float blendOverlay(float base, float blend, float opacity) {
        return blendOverlay(base, blend) * opacity + base * (1.0 - opacity);
      }

      vec4 blendOverlay(vec4 base, vec4 blend) {
        return vec4(
          blendOverlay(base.r, blend.r),
          blendOverlay(base.g, blend.g),
          blendOverlay(base.b, blend.b),
          (base.a + blend.a) / 2.0
        );
      }

      vec4 blendOverlay(vec4 base, vec4 blend, float opacity) {
        return vec4(
          blendOverlay(base.r, blend.r, opacity),
          blendOverlay(base.g, blend.g, opacity),
          blendOverlay(base.b, blend.b, opacity),
          (base.a + blend.a) / 2.0
        );
      }

      //
      // Bump map functions
      // 

      vec2 dHdxy_fwd() {

        vec2 dSTdx = dFdx( vUv );
        vec2 dSTdy = dFdy( vUv );

        float inverseFoilCoverage = 1.0 - texture2D( foilMap, vUv ).r * foilOpacity;

        float scaleMax = max(bumpScaleBase, bumpScaleCustom);
        float scaleBaseNorm = bumpScaleBase / scaleMax;
        float scaleCustomNorm = bumpScaleCustom / scaleMax;

        float Hll = scaleMax * blendOverlay(
          0.5 + (texture2D( bumpMapBase,   vUv ).x - 0.5) * scaleBaseNorm * inverseFoilCoverage,
          0.5 + (texture2D( bumpMapCustom, vUv ).x - 0.5) * scaleCustomNorm
        );
        float dBx = scaleMax * blendOverlay(
          0.5 + (texture2D( bumpMapBase,   vUv + dSTdx ).x - 0.5) * scaleBaseNorm * inverseFoilCoverage,
          0.5 + (texture2D( bumpMapCustom, vUv + dSTdx ).x - 0.5) * scaleCustomNorm
        ) - Hll;
        float dBy = scaleMax * blendOverlay(
          0.5 + (texture2D( bumpMapBase,   vUv + dSTdy ).x - 0.5) * scaleBaseNorm * inverseFoilCoverage,
          0.5 + (texture2D( bumpMapCustom, vUv + dSTdy ).x - 0.5) * scaleCustomNorm
        ) - Hll;

        return vec2( dBx, dBy );

      }

      vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {

        // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988

        vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
        vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
        vec3 vN = surf_norm;		// normalized

        vec3 R1 = cross( vSigmaY, vN );
        vec3 R2 = cross( vN, vSigmaX );

        float fDet = dot( vSigmaX, R1 ) * faceDirection;

        vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
        return normalize( abs( fDet ) * surf_norm - vGrad );

      }

      // 
      // Main
      // 

      void main() {

        vec3 normal = perturbNormalArb( -vViewPosition, vNormal, dHdxy_fwd(), 1.0 );

        ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );

        // Combine diffuse textures

        vec4 diffuseColor = blendOverlay(
          texture2D( diffuseMapBase, vUv ),
          texture2D( diffuseMapCustom, vUv )
        );

        // Foil

        vec2 foilIndex = vec2(
          sin(normal.y * foilDetail  +  vViewPosition.y * foilDetail / 10.0),
          cos(normal.x * foilDetail  +  vViewPosition.x * foilDetail / 10.0)
        ) / 2.0;
        foilIndex = vec2(0.0, 1.0) + foilUvSize / 2.0 + foilIndex * foilUvSize;

        vec4 foilColor = texture2D( diffuseMapCustom, foilIndex );
        float foilCoverage = texture2D( foilMap, vUv ).r * foilOpacity;

        diffuseColor = mix(diffuseColor, foilColor, foilCoverage);

        // Lighting

        float specularStrength = 1.0 + foilCoverage * foilSpecular;

        #include <lights_phong_fragment>
        #include <lights_fragment_begin>
        #include <lights_fragment_maps>
        #include <lights_fragment_end>

        vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse 
                           + reflectedLight.directSpecular + reflectedLight.indirectSpecular;

        gl_FragColor = vec4( outgoingLight, diffuseColor.a );

      }
    `;

    const material = new THREE.ShaderMaterial({
      vertexShader,
      fragmentShader,
      uniforms: Object.assign(
        {
          specular:          { type: 'c', value: new THREE.Color(0x333333) },
          shininess:         { value: 10 },
          thickness:         { value: 1.4 },

          diffuseMapBase:    { type: 't', value: textures.shared_diffuse_overlay },
          diffuseMapCustom:  { type: 't', value: textures.TDM_diffuse },

          bumpMapBase:       { type: 't', value: textures.shared_bump_buckram },
          bumpMapCustom:     { type: 't', value: textures.TDM_bump },
          bumpScaleBase:     { value: 0.05 },
          bumpScaleCustom:   { value: 0.1 },

          foilMap:           { type: 't', value: textures.TDM_foil },
          foilDetail:        { value: 0.5 },
          foilOpacity:       { value: 1.0 },
          foilSpecular:      { value: 0.1 },
        }, 
        THREE.UniformsLib['lights']
      ),
      lights: true,
      defines: {
        USE_UV: '',
        USE_MAP: '',
        USE_BUMPMAP: '',
      },
    });

    // Presets

    const presets = {
      'Prince of Persia': {
        shininess:        10,
        thickness:        1.3,
        diffuseMapCustom: textures.POP_diffuse,
        bumpMapBase:      textures.shared_bump_buckram,
        bumpScaleBase:    0.05,
        bumpMapCustom:    textures.POP_bump,
        bumpScaleCustom:  0.15,
        foilMap:          textures.shared_foil_none,
      },
      'Get Together': {
        shininess:        15,
        thickness:        0.8,
        diffuseMapCustom: textures.GT_diffuse,
        bumpMapBase:      textures.shared_bump_paper,
        bumpScaleBase:    0.07,
        bumpMapCustom:    textures.GT_bump,
        bumpScaleCustom:  0.10,
        foilMap:          textures.GT_foil,
        foilDetail:       1.5,
        foilSpecular:     -0.75,
      },
      'The Dream Machine': {
        shininess:        10,
        thickness:        1.4,
        diffuseMapCustom: textures.TDM_diffuse,
        bumpMapBase:      textures.shared_bump_buckram,
        bumpScaleBase:    0.05,
        bumpMapCustom:    textures.TDM_bump,
        bumpScaleCustom:  0.10,
        foilMap:          textures.TDM_foil,
        foilDetail:       0.5,
        foilSpecular:     0.1,
      },
    };

    let book;

    new THREE.GLTFLoader().load('v2-assets/shared_geometry.gltf', gltf => {
      book = gltf.scene;
      book.rotation.set(-0.2, -1.1, .8);
      book.children[0].material = material;
      scene.add(book);

      Object.entries(presets['Get Together']).forEach(([key, val]) => {
        material.uniforms[key].value = val;
      });
    });

    // 
    // Totally unnecessary shadow
    // 

    const shadowMap = new THREE.TextureLoader().load('v2-assets/shadow.png');
    const shadowMat = new THREE.MeshBasicMaterial({
      map: shadowMap,
      transparent: true,
      opacity: 0.25,
    });

    const shadowGeo = new THREE.PlaneGeometry(20, 20);
    const shadow = new THREE.Mesh(shadowGeo, shadowMat);
    shadow.rotation.x = Math.PI / -2;
    shadow.position.y = -15;

    scene.add(shadow);

    // 
    // Render
    // 

    function render() {
      renderer.render(scene, camera);
      requestAnimationFrame(render);
    };

    render();

  </script>
</body>

</html>